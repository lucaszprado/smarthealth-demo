require 'caxlsx'

# Service for exporting data to Excel files
#
# This service provides a general-purpose Excel export functionality that can handle
# arrays of hashes or ActiveRecord relations and convert them to Excel format.
#
# @example Basic usage with array of hashes
#   data = [
#     { id: 1, name: "John", email: "john@example.com" },
#     { id: 2, name: "Jane", email: "jane@example.com" }
#   ]
#   headers = ["ID", "Name", "Email"]
#   service = ExcelExportService.new(data, headers)
#   file_content = service.generate
#
# @example Usage with ActiveRecord relation
#   users = User.select(:id, :name, :email)
#   headers = ["ID", "Name", "Email"]
#   service = ExcelExportService.new(users, headers)
#   service.save_to_file("users_export.xlsx")
#
# @since 1.0.0

class ExcelExportService

  # Initialize the Excel export service
  #
  # @param data [Array<Hash>, ActiveRecord::Relation] The data to export
  # @param headers [Array<String>] Column headers for the Excel file
  # @param sheet_name [String] Name of the Excel sheet (default: "Sheet1")
  def initialize(data, headers, sheet_name: "Sheet1")
    @data = data
    @headers = headers
    @sheet_name = sheet_name
  end

  # Generate Excel file content in memory
  #
  # @return [String] Binary content of the Excel file
  #  It creates an Excel workbook in memory using the Axlsx gem, adds the headers and data rows, and returns the workbook's binary content via package.to_stream.read.
  # @example
  #   service = ExcelExportService.new(data, headers)
  #   file_content = service.generate
  #   File.write("export.xlsx", file_content)
  def generate
    package = Axlsx::Package.new
    workbook = package.workbook

    workbook.add_worksheet(name: @sheet_name) do |sheet|
      # Add header row with styling
      sheet.add_row @headers, style: header_style(workbook)

      # Add data rows
      processed_data.each do |row|
        sheet.add_row row
      end

      # Auto-fit column widths
      sheet.column_widths *calculate_column_widths
    end

    # Generate the Excel file
    # Converts the Excel workbook (package) into a binary stream and reads its contents into memory.
    # The to_stream method creates a stream of the Excel file, and read retrieves all the binary content from that stream.
    # The Excel binary content returned by package.to_stream.read is in ASCII-8BIT encoding (binary format)
    package.to_stream.read
  end

  # Save Excel file to specified path
  #
  # @param file_path [String] Path where to save the Excel file
  # @return [String] The file path where the file was saved
  # @example
  #   service = ExcelExportService.new(data, headers)
  #   service.save_to_file("tmp/export.xlsx")
  # mode: 'wb' is used when the file to be written in the binary mode. File.write by default expects UTF-8 text. 'w' = write mode and 'b' = binary mode.
  # This tells Ruby to write the file in binary mode, which:
  # Prevents encoding conversion - Ruby won't try to convert from ASCII-8BIT to UTF-8
  # Preserves the binary Excel format exactly as generated by the caxlsx gem
  # Ensures the Excel file is valid and can be opened by Excel applications
  def save_to_file(file_path)
    File.write(file_path, generate, mode: 'wb') # mode: 'wb' is used when the file to be written in the binary mode. File.write by default expects UTF-8 text. 'w' = write mode and 'b' = binary mode.
    file_path
  end

  # Save Excel file to Rails tmp directory with timestamp
  #
  # @param base_filename [String] Base name for the file (without extension)
  # @return [String] The full path where the file was saved
  # @example
  #   service = ExcelExportService.new(data, headers)
  #   path = service.save_to_tmp("biomarkers_export")
  #   # Returns: "tmp/biomarkers_export_20241201_143022.xlsx"
  def save_to_tmp(base_filename)
    timestamp = Time.now.strftime("%Y%m%d_%H%M%S")
    filename = "#{base_filename}_#{timestamp}.xlsx"
    file_path = Rails.root.join("tmp", filename)
    save_to_file(file_path)
  end

  private

  # Process data to ensure consistent format
  #
  # Converts ActiveRecord relations to arrays and ensures all data
  # is in a format suitable for Excel export
  #
  # @return [Array<Array>] Processed data as array of arrays
  # @example With ActiveRecord::Relation
  #   # Given headers: ["Name", "Age"]
  #   # And @data is User.where(age: 25) returning users with:
  #   # <User id: 1, name: "John", age: 25>
  #   # <User id: 2, name: "Jane", age: 25>
  #   # Returns: [["John", 25], ["Jane", 25]]
  #
  # @example With Array of Hashes
  #   # Given headers: ["Name", "Age"]
  #   # And @data is [{"Name" => "John", "Age" => 25}, {"Name" => "Jane", "Age" => 25}]
  #   # Returns: [["John", 25], ["Jane", 25]]
  def processed_data
    case @data
    when ActiveRecord::Relation
      @data.map { |record| extract_values_from_record(record) }
    when Array
      @data.map { |hash| extract_values_from_hash(hash) }
    else
      raise ArgumentError, "Unsupported data type: #{@data.class}, expected Array or ActiveRecord::Relation"
    end
  end

  # Extract values from ActiveRecord record object
  #
  # @param record [ActiveRecord::Base] The record to extract values from
  # @return [Array] Array of values corresponding to headers

  def extract_values_from_record(record)
    @headers.map do |header|
      # Convert header to attribute name (downcase and replace spaces with underscores)
      attribute_name = header.downcase.gsub(/\s+/, '_')

      # We try different key formats that might be defined to match active record attributes
      record.try(attribute_name) || record.try(attribute_name.to_sym) || "" # The try method is used to safely handle cases where the attribute might not exist, preventing NoMethodError exceptions. try is a Rails method (specifically from ActiveSupport) that extends all Ruby objects.
    end
  end

  # Extract values from hash
  #
  # @param hash [Hash] The hash to extract values from
  # @return [Array] Array of values corresponding to headers
  def extract_values_from_hash(hash)
    @headers.map do |header|
      # Try different key formats to match the header name with the hash key name
      key_variations = [
        header, # Match the case where the initializer header (instance variable) is the same as the hash key name
        header.downcase,
        header.downcase.gsub(/\s+/, '_'),
        header.downcase.gsub(/\s+/, '_').to_sym
      ]

      value = nil
      key_variations.each do |key|
        value = hash[key]
        break if value
      end

      value || ""
    end
  end

  # Define header style for Excel
  #
  # @param workbook [Axlsx::Workbook] The workbook to create styles for
  # @return [Axlsx::Style] Style object for headers
  def header_style(workbook)
    workbook.styles.add_style(
      bg_color: "366092",
      fg_color: "FFFFFF",
      b: true,
      alignment: { horizontal: :center},
    )
  end

  def calculate_column_widths
    # Start with header lengths
    widths = @headers.map { |header| header.length + 2 }

     # Check first few rows of data to adjust widths
     sample_data = processed_data.first(10)
     sample_data.each do |row|

      # This block calculates optimal column widths for an Excel sheet by:
      # Looking at each cell in a row
      # Getting the length of the cell's content (plus 2 for padding)
      # Comparing three values: current width, cell content length, and 50 (max width)
      # Taking the middle value (sort[1]) to ensure width stays between minimum (current) and maximum (50)
      row.each_with_index do |cell, index|
         cell_length = cell.to_s.length + 2
         widths[index] = [widths[index], cell_length, 50].sort[1] # Min 2, Max 50
       end
     end

     widths
  end
end
